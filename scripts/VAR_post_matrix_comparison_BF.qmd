---
title: "GVAR - Posterior Matrix Comparisons"
output:
  html_document:
    toc: yes
    toc_float: yes
    collapsed: no
    smooth_scroll: yes
---

```{r setup, include = FALSE}
# Libraries
packages <- c(
  "tidyverse",
  "devtools",
  "rmarkdown",
  "psych",
  "cmdstanr",
  "rstan",
  "loo",
  "bayesplot",
  "posterior",
  "bayestestR",
  "here",
  "sjlabelled",
  "tsnet",
  "BGGM",
  "graphicalVAR",
  "mvtnorm"
)
#remotes::install_github("donaldRwilliams/BGGM")
#devtools::install_github("bsiepe/tsnet")
if (!require("pacman")) install.packages("pacman")
pacman::p_load(packages, update = F, character.only = T)

source(here("scripts","functions.R"))
set.seed(35037)
```

# Posterior comparisons

### Simulate gVAR-Data

Simulate data from same model, slightly different DGP, strongly different DGP
```{r}
l_changed_graphs_0305 <- readRDS(here("data/l_changed_graphs_0305.rds"))
# data generating graphs
gvar_mod1 <- l_changed_graphs_0305[["graph5"]][["truegraph"]]
gvar_mod2 <- l_changed_graphs_0305[["graph5"]][["const0.05"]]
gvar_mod3 <- l_changed_graphs_0305[["graph5"]][["const0.1"]]
gvar_mod4 <- l_changed_graphs_0305[["graph5"]][["const0.15"]]
# number of time points
t <- 500
# simulate data
data_1a <- graphicalVAR::graphicalVARsim(nTime = t,
                                         beta = gvar_mod1$beta,
                                         kappa = gvar_mod1$kappa)
data_1b <- graphicalVAR::graphicalVARsim(nTime = t,
                                         beta = gvar_mod1$beta,
                                         kappa = gvar_mod1$kappa)
data_2 <- graphicalVAR::graphicalVARsim(nTime = t,
                                        beta = gvar_mod2$beta,
                                        kappa = gvar_mod2$kappa)
data_3 <- graphicalVAR::graphicalVARsim(nTime = t,
                                        beta = gvar_mod3$beta,
                                        kappa = gvar_mod3$kappa)
data_4 <- graphicalVAR::graphicalVARsim(nTime = t,
                                        beta = gvar_mod4$beta,
                                        kappa = gvar_mod4$kappa)
```

### Fit networks 
```{r message=FALSE}
method <- "variational"
net_1a_fit <-
  fit_gVAR_stan(
    data = data_1a,
    iter_sampling = 500,
    method = method
  )
net_1b_fit <-
  fit_gVAR_stan(
    data = data_1b,
    iter_sampling = 500,
    method = method
  )
net_2_fit <-
  fit_gVAR_stan(
    data = data_2,
    iter_sampling = 500,
    method = method
  )
net_3_fit <-
  fit_gVAR_stan(
    data = data_3,
    iter_sampling = 500,
    method = method
  )
net_4_fit <-
  fit_gVAR_stan(
    data = data_4,
    iter_sampling = 500,
    method = method
  )
```

### Extract posterior matrices for Beta
```{r}
beta_post_1a <-
  rstan::extract(net_1a_fit, "Beta", permuted = FALSE) %>% as_draws_matrix() 
beta_post_1b <-
  rstan::extract(net_1b_fit, "Beta", permuted = FALSE) %>% as_draws_matrix() 
beta_post_2 <-
  rstan::extract(net_2_fit, "Beta", permuted = FALSE) %>% as_draws_matrix()
beta_post_3 <-
  rstan::extract(net_3_fit, "Beta", permuted = FALSE) %>% as_draws_matrix()
beta_post_4 <-
  rstan::extract(net_4_fit, "Beta", permuted = FALSE) %>% as_draws_matrix()
```

### Function for comparison
```{r}
compare_mat_Beta <-
  function(mat1,
           mat2,
           # number of bootstrap samples
           bootstrap_samples = 0,
           # must be a list containing 2 matrices
           H1_custom_priors = NULL,
           # normal SD
           H1_prior_scale = 0.5,
           # "normal" = SD, "uniform" = range / 2
           H0_prior_scale = NULL,
           # c("normal", "uniform", "posterior_uncertainty")
           H0_distribution = "uniform",
           # plot densities for null, posterior, and prior
           plot = TRUE,
           # upper limit of the x-axis
           plot_xlim = NULL,
           # upper limit of the y-axis
           plot_ylim = NA 
           ) {
           #### with bootstrapping ###
           if (bootstrap_samples > 0) {
             # sample rows from posterior iterations
             rows1 <-
               sample(1:nrow(mat1),
                      size = bootstrap_samples,
                      replace = TRUE)
             rows2 <-
               sample(1:nrow(mat2),
                      size = bootstrap_samples,
                      replace = TRUE)
             # assemble new posterior draws_matrices
             mat1 <-
               purrr::map(
                 .x = rows1,
                 .f = function(.x) {
                   mat1[.x,]
                 }
               ) %>%
               do.call(rbind, .)
             mat2 <-
               purrr::map(
                 .x = rows2,
                 .f = function(.x) {
                   mat2[.x, ]
                 }
               ) %>%
               do.call(rbind, .)
             # compute differences between matrices
             diff_post <- abs(mat1 - mat2) %>%
               apply(., 1, sum)
             
             
             ### compute prior difference matrices
             
             # use custom priors if exist
             if (typeof(H1_custom_priors) == "list" &
                 length(H1_custom_priors) == 2) {
               loc <- H1_custom_priors[[1]] %>% as.vector()
               scale <- H1_custom_priors[[2]] %>% as.vector()
               diff_prior <- abs(
                 lapply(1:length(loc), function(n) {
                   rnorm(n = bootstrap_samples,
                         mean = loc[n],
                         sd = scale[n])
                 }) %>%
                   do.call(cbind, .) -
                   lapply(1:length(loc), function(n) {
                     rnorm(n = bootstrap_samples,
                           mean = loc[n],
                           sd = scale[n])
                   }) %>%
                   do.call(cbind, .)
               ) %>%
                 matrix(., ncol = ncol(mat1)) %>%
                 apply(., 1, sum)
               
             } else{
               # use default priors
               diff_prior <-
                 abs(
                   rnorm(
                     n = bootstrap_samples * ncol(mat1),
                     mean = 0,
                     sd = H1_prior_scale
                   ) -
                     rnorm(
                       n = bootstrap_samples * ncol(mat1),
                       mean = 0,
                       sd = H1_prior_scale
                     )
                 ) %>%
                 matrix(., ncol = ncol(mat1)) %>%
                 apply(., 1, sum)
             }
           } else{
             ### NO bootstrappping ###
             
             diff_post <- mat1 - mat2
             attr(diff_post, which = "class") <- "matrix"
             
             diff_post <- abs(diff_post) %>%
               apply(., 1, sum)
             
             # prior difference matrices
             if (typeof(H1_custom_priors) == "list" &
                 length(H1_custom_priors) == 2) {
               loc <- H1_custom_priors[[1]] %>% as.vector()
               scale <- H1_custom_priors[[2]] %>% as.vector()
               diff_prior <- abs(
                 lapply(1:length(loc), function(n) {
                   rnorm(n = 4e4,
                         mean = loc[n],
                         sd = scale[n])
                 }) %>%
                   do.call(cbind, .) -
                   lapply(1:length(loc), function(n) {
                     rnorm(n = 4e4,
                           mean = loc[n],
                           sd = scale[n])
                   }) %>%
                   do.call(cbind, .)
               ) %>%
                 matrix(., ncol = ncol(mat1)) %>%
                 apply(., 1, sum)
               # use default priors
             } else{
               diff_prior <- abs(
                 rnorm(
                   n = 4e4 * ncol(mat1),
                   mean = 0,
                   sd = H1_prior_scale
                 ) -
                   rnorm(
                     n = 4e4 * ncol(mat1),
                     mean = 0,
                     sd = H1_prior_scale
                   )
               ) %>%
                 matrix(., ncol = ncol(mat1)) %>%
                 apply(., 1, sum)
             }
           }
           
           # distribution for null rope range
           if (H0_distribution == "normal") {
             if (is.null(H0_prior_scale)) {
               H0_prior_scale <- .05
             }
             diff_null <- abs(
               rnorm(
                 n = 4e4 * ncol(mat1),
                 mean = 0,
                 sd = H0_prior_scale
               ) -
                 rnorm(
                   n = 4e4 * ncol(mat1),
                   mean = 0,
                   sd = H0_prior_scale
                 )
             ) %>%
               matrix(., ncol = ncol(mat1)) %>%
               apply(., 1, sum)
           }
           if (H0_distribution == "uniform") {
             if (is.null(H0_prior_scale)) {
               H0_prior_scale <- .1
             }
             
             diff_null <- abs(
               runif(
                 n = 4e4 * ncol(mat1),
                 min = -H0_prior_scale,
                 max = H0_prior_scale
               ) -
                 runif(
                   n = 4e4 * ncol(mat1),
                   min = -H0_prior_scale,
                   max = H0_prior_scale
                 )
             ) %>%
               matrix(., ncol = ncol(mat1)) %>%
               apply(., 1, sum)
           }
           if (H0_distribution == "posterior_uncertainty") {
             # sample rows from posterior iterations
             rows1_null <-
               sample(1:nrow(mat1),
                      size = nrow(mat1),
                      replace = FALSE)
             
             # assemble new posterior draws_matrices
             mat1_null <-
               purrr::map(
                 .x = rows1_null,
                 .f = function(.x) {
                   mat1[.x, ]
                 }
               ) %>%
               do.call(rbind, .)
             # compute differences between matrices
             diff_null <- abs(mat1 - mat1_null) %>%
               apply(., 1, sum)
           }
           # HDI for Null distribution, CI_high will be used as upper ROPE limit
           null_ci <- bayestestR::hdi(diff_null, ci = .99)
           
           post_in_rope <-
             diff_post[diff_post < max(diff_null)] %>%
             length() / length(diff_post) * 100
           
           prior_in_rope <-
             diff_post[diff_prior < max(diff_null)] %>%
             length() / length(diff_prior) * 100
           
           # plot prior vs. posterior
           if (isTRUE(plot)) {
             # combine diff_post and diff_prior in a single column of a dataframe
             # with another column as an indicator if it is a posterior or prior
             # distribution
             if (is.null(plot_xlim)) {
               plot_xlim <- max(median(diff_prior),
                                median(diff_post),
                                median(diff_null))
             }
             df_samples <- data.frame(posterior = diff_post,
                                      prior = diff_prior) %>%
               tidyr::pivot_longer(
                 cols = c(posterior, prior),
                 names_to = "distribution",
                 values_to = "value"
               ) %>%
               rbind(data.frame(distribution = "null",
                                value = diff_null))
             
             plot <- df_samples %>%
               ggplot2::ggplot() +
               ggplot2::geom_density(aes(value, fill = distribution),
                                     alpha = .5) +
               ggplot2::geom_vline(xintercept = null_ci$CI_low) +
               ggplot2::geom_vline(xintercept = null_ci$CI_high) +
               ggplot2::scale_x_continuous(limits = c(0, plot_xlim),
                                           expand = expansion()) +
               ggplot2::scale_y_continuous(limits = c(0, plot_ylim),
                                           expand = expansion()) +
               ggplot2::labs(x = "Difference", y = "Density") +
               ggplot2::theme_light() +
               ggplot2::theme(panel.grid = element_blank())
             
             print(plot)
           }
           
           ### Compute BF for H1
           mean_post <- mean(diff_post)
           sd_post <- sd(diff_post)
           mean_prior <- mean(diff_prior)
           sd_prior <- sd(diff_prior)

           BF_01 <- mean(exp(
             dnorm(diff_null, mean_post, sd_post, log = TRUE) -
             dnorm(diff_null, mean_prior, sd_prior, log = TRUE)))
           BF_10 <- 1 / BF_01
           
           
           
           
           # if there is no overlap of posterior and null omit BF
           if (post_in_rope == 0 & prior_in_rope == 0) {
             log_BF <- NA
             overlap_coef_post <- NA
             overlap_coef_prior <- NA
           }
           # if there is an overlap for posterior and null but not for prior and null omit BF
           if (post_in_rope > 0 & prior_in_rope == 0) {
             log_BF <- NA
             overlap_coef_post <- bayestestR::overlap(diff_post, diff_null)
             overlap_coef_prior <- NA
           }
           if (post_in_rope == 0 & prior_in_rope > 0) {
             log_BF <- NA
             overlap_coef_post <- NA
             overlap_coef_prior <- bayestestR::overlap(diff_prior, diff_null)
           }
           if (post_in_rope > 0 & prior_in_rope > 0) {
             # compute BF
             log_BF <-
               bayestestR::bf_parameters(
                 posterior = diff_post,
                 prior = diff_prior,
                 null = c(null_ci$CI_low, null_ci$CI_high),
                 direction = 0
               ) %>%
               unlist()
             
             overlap_coef_post <- bayestestR::overlap(diff_post, diff_null)
             overlap_coef_prior <- bayestestR::overlap(diff_prior, diff_null)
           }
           # df with log_BF and overlap coef
           df_results <- data.frame(
             round(log_BF, 2),
             BF_10,
             round(overlap_coef_post * 100, 2),
             round(post_in_rope, 2),
             round(overlap_coef_prior * 100, 2),
             round(prior_in_rope, 2),
             row.names = NULL
           )
           names(df_results) <-
             c("log BF_10",
               "BF_10",
               "% density overlap null-post",
               "% posterior < null CI_high",
               "% density overlap null-prior",
               "% prior < null CI_high")
           
           print(df_results)
           
           # return list with results silently
           return(invisible(
             list(
               log_BF_10 = log_BF,
               BF_10 = BF_10,
               post_overlap_coef = overlap_coef_post %>% as.double(),
               post_below_null_ub = post_in_rope,
               prior_overlap_coef = overlap_coef_prior %>% as.double(),
               prior_below_null_ub = prior_in_rope
             )
           ))
           # clean up
           rm(mat1, mat2, diff_post, diff_prior, diff_null)
           }
```

### Compare matrices
```{r}
n_boot <- 1e4
null_dist <- "normal"
prior_scale <- 100
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_1b,
  bootstrap_samples = n_boot,H1_prior_scale = prior_scale,
  H0_distribution = null_dist,
  plot = TRUE
)
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_2,
  bootstrap_samples = n_boot,H1_prior_scale = prior_scale,
  H0_distribution = null_dist,
  plot = TRUE
)
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_3,
  bootstrap_samples = n_boot,H1_prior_scale = prior_scale,
  H0_distribution = null_dist,
  plot = TRUE
) 
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_4,
  bootstrap_samples = n_boot,H1_prior_scale = prior_scale,
  H0_distribution = null_dist,
  plot = TRUE
) 
```

### Compare different Null distributions
```{r}
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_1b,
  H0_prior_scale = .1, 
  H0_distribution = "uniform",
  bootstrap_samples = 4e4,
  plot = TRUE,
  plot_xlim = 20, 
  plot_ylim = 4
)
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_1b,
  H0_prior_scale = .05, 
  H0_distribution = "normal",
  bootstrap_samples = 4e4,
  plot = TRUE,
  plot_xlim = 20, 
  plot_ylim = 4
)
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_1b, 
  H0_distribution = "posterior_uncertainty",
  bootstrap_samples = 4e4,
  plot = TRUE,
  plot_xlim = 20, 
  plot_ylim = 4
)
```

### Use custom priors
Instead of a centered prior with a fixed scale we can specify custom priors as a list of two matrices each containing the means and standard deviations for the normal priors on the single parameters in the parameter matrix.
```{r}
n_boot <- 4e4
null_dist <- "posterior_uncertainty"
# initialize prior matrices
custom_prior <- list(
  loc = matrix(0, ncol = ncol(gvar_mod1$beta), nrow = nrow(gvar_mod1$beta)),
  scale = matrix(.5, ncol = ncol(gvar_mod1$beta), nrow = nrow(gvar_mod1$beta))
)
# change certain coefficients
custom_prior[[2]][1,] <- .1
custom_prior[[2]][2,] <- .01
custom_prior[[2]][3,] <- .1
custom_prior[[2]][5,] <- .1
custom_prior[[2]][6,] <- .01

compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_1b,
  bootstrap_samples = n_boot,
  H1_custom_priors = custom_prior,
  H0_distribution = null_dist,
  plot = TRUE
)
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_2,
  bootstrap_samples = n_boot,
  H1_custom_priors = custom_prior,
  H0_distribution = null_dist,
  plot = TRUE
)
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_3,
  bootstrap_samples = n_boot,
  H1_custom_priors = custom_prior,
  H0_distribution = null_dist,
  plot = TRUE
) 
compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_4,
  bootstrap_samples = n_boot,
  H1_custom_priors = custom_prior,
  H0_distribution = null_dist,
  plot = TRUE
) 
```

```{r}
n <- 30
log_BFs <- rep(NA, n)
for (i in 1:n) {
  list <- compare_mat_Beta(
  mat1 = beta_post_1a,
  mat2 = beta_post_3,
  bootstrap_samples = n_boot,
  H1_custom_priors = custom_prior,
  H0_distribution = "uniform",
  plot = FALSE)
  
  log_BFs[i] <- list[[4]] - list[[6]]
}
```

```{r}
hist(exp(log_BFs),breaks = 30)
range(exp(log_BFs))
sd(log_BFs)
```


```{r}


data.frame(log_BFs = log_BFs, log_BFs_boot = log_BFs_boot) %>%
      ggplot2::ggplot() +
      ggplot2::geom_histogram(aes(log_BFs),
                            fill = "red",
                            alpha = .5,
                            binwidth = .1) +
      ggplot2::geom_histogram(aes(log_BFs_boot),
                            fill = "blue",
                            alpha = .5,
                            binwidth = .1) +
      ggplot2::xlim(-5, 0)

```






