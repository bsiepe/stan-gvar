---
title: "implementation-comparison-sim"
format: html
editor: visual
---

Here, we investigate the different implementations of the Bayesian gVAR.

# Preparation

```{r}
library(BGGM)
library(tidyverse)
library(here)
here::set_here("~/bjoern/stan-gvar.Rproj")
source(here("scripts/functions.R"))
library(SimDesign)
```

# Writing simulation functions

## Creating Design

```{r}
## Variable Objects
# Number of timepoints
tp <- c(50, 200, 400)
# For testing
# tp <- 200

# Amount of change between DGP
dgp <- c("graph3", "graph4", "graph5")

# For testing
# dgp <- "graph4"


df_design <- createDesign(tp = tp,
                          dgp = dgp)

## Fixed Objects
# These are used in SimDesign to specify objects passed to later functions
# that do not vary across conditions

# DGPs
l_changed_graphs_0305 <- readRDS(here("data/l_changed_graphs_0305.RDS"))

graph3 <- l_changed_graphs_0305[["graph3"]][["truegraph"]]
graph3$pcor <- -cov2cor(graph3$kappa)
diag(graph3$pcor) <- 0
graph4 <- l_changed_graphs_0305[["graph4"]][["truegraph"]]
graph4$pcor <- -cov2cor(graph4$kappa)
diag(graph4$pcor) <- 0
graph5 <- l_changed_graphs_0305[["graph5"]][["truegraph"]]
dgp_list <- list("graph3" = graph3,
                 "graph4" = graph4,
                 "graph5" = graph5)


# Further simulation parameters
sim_pars <- list(means = 0,
                 dgp_list = dgp_list,
                 nvar = 6,
                 rho_prior = 0.25,
                 beta_prior = 0.5,
                 bggm_iter = 50000,
                 stan_iter = 100,
                 mplus_iter = 2000,
                 dist_draws = 10000)   # number of distances computed between matrices

```

## Data Generating Function

```{r}
sim_generate <- function(condition, fixed_objects = NULL) {
  
  # obtain fixed parameters
  # this is NOT like the typical attach
  SimDesign::Attach(fixed_objects)
  
  # obtain condition parameters
  tp <- condition$tp
  dgp_ind <- condition$dgp
  dgp <- fixed_objects$dgp_list[[dgp_ind]]
  
  
  # Simulate dataset under true
  data <- as.data.frame(graphicalVAR::graphicalVARsim(nTime = tp,
                                              beta = dgp$beta,
                                              kappa = dgp$kappa,
                                              mean = means))
  
  # Standardize data
  data <- as.data.frame(scale(data))
  
  
  return(data)
  
  
}
```

## Analysis Function

```{r}
sim_analyse <- function(condition, dat, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)    
  
  #--- Fit BGGM model
  fit_bggm <- BGGM::var_estimate(dat,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  

  
  #--- Fit Stan LKJ
  # maybe use this?
  fit_stan_lkj <-  fit_gVAR_stan(
    data = dat,
    cov_prior = "LKJ",
    priors = NULL,
    n_cores = 1,
    iter_sampling = stan_iter,
    method = "sampling",
    server = TRUE
  )
  # Convert to array
  stan_arr_lkj <- stan_fit_convert(fit_stan_lkj)
  
  
  #--- Fit Stan Inverse Wishart
  fit_stan_iw <-  fit_gVAR_stan(
    data = dat,
    cov_prior = "IW",
    priors = NULL,
    n_cores = 1,
    iter_sampling = stan_iter,
    method = "sampling",
    server = TRUE
  )
  # Convert to array
  stan_arr_iw <- stan_fit_convert(fit_stan_iw)
  
  #--- Fit Mplus defaults
  # Not for now, 
  # is a bit tricky
  # http://philchalmers.github.io/SimDesign/html/14-Calling_external_programs.html
  
  
  
  
  #--- Return
  ret_analyse <- list(fit_bggm = fit_bggm,
                      fit_stan_lkj = stan_arr_lkj,
                      fit_stan_iw = stan_arr_iw)
  return(ret_analyse)
  
}
```

## Summary Function

TODO - fix proper summaries

```{r}
sim_summarise <- function(condition, results, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)  
  
  ret <- list()
  
  #--- Obtain condition parameters and DGP
  dgp_ind <- condition$dgp
  dgp <- dgp_list[[dgp_ind]]
  
  
  #--- Compare against DGP
  # lapply over results
  # also obtain posterior summary (mean and cov matrix)
  posterior_summary <- function(sample_arr,
                                pcor_name = "pcor"){
    iter <- dim(sample_arr)[3]

    # Point estimates
    beta_mean <- apply(sample_arr$beta, c(1, 2), mean)
    beta_median <- apply(sample_arr$beta, c(1,2), stats::median)
    pcor_mean <- apply(sample_arr[[pcor_name]], c(1, 2), mean)
    pcor_median <- apply(sample_arr[[pcor_name]], c(1,2), stats::median)

    # HDIs
    beta_hdi <- apply(sample_arr$beta, c(1, 2), function(x) bayestestR::hdi(x, .95))
    pcor_hdi <- apply(sample_arr[[pcor_name]], c(1, 2), function(x) bayestestR::hdi(x, .95))


    return(list(beta_mean = beta_mean, 
                pcor_mean = pcor_mean,
                beta_hdi = beta_hdi, 
                pcor_hdi = pcor_hdi))
  }
  
  
  
  #-- BGGM
  comp_bggm <- lapply(results, function(x){
    array_compare_dgp(x$fit_bggm$fit,
                      dgp = dgp,
                      samples_pcor_name = "pcors",
                      plot = FALSE)
  })
  
  summary_bggm <- lapply(results, function(x){
    beta_mean <- x$fit_bggm$beta_mu
    pcor_mean <- x$fit_bggm$pcor_mu
    return(list(beta_mean = beta_mean, pcor_mean = pcor_mean))
  })

  
  
  #-- Stan LKJ
  # Compare to dgp
  comp_lkj <- lapply(results, function(x){
    array_compare_dgp(x$fit_stan_lkj,
                      dgp = dgp,
                      plot = FALSE)
  })
  
  summary_lkj <- lapply(results, function(x){
    posterior_summary(x$fit_stan_lkj, "rho")
  })  
  
  
  
  #-- Stan IW
  comp_iw <- lapply(results, function(x){
    array_compare_dgp(x$fit_stan_iw,
                      dgp = dgp,
                      plot = FALSE)
  })
  
  summary_iw <- lapply(results, function(x){
    posterior_summary(x$fit_stan_iw, "rho")
  })
  
  #--- Compare with one another
  # BGGM vs Stan IW
  # BGGM vs Stan LKJ
  # Stan IW vs Stan LKJ
  pairwise_comp <- list()
  
  for(i in seq_along(results)){
    pairwise_comp[[i]] <- list()
    pairwise_comp[[i]]$mean_beta_diff_bggm_iw <- summary_bggm[[i]]$beta_mean - summary_iw[[i]]$beta_mean
    pairwise_comp[[i]]$mean_beta_diff_bggm_lkj <- summary_bggm[[i]]$beta_mean - summary_lkj[[i]]$beta_mean
    pairwise_comp[[i]]$mean_beta_diff_lkj_iw <- summary_iw[[i]]$beta_mean - summary_lkj[[i]]$beta_mean
    pairwise_comp[[i]]$mean_pcor_diff_bggm_iw <- summary_bggm[[i]]$pcor_mean - summary_iw[[i]]$pcor_mean
    pairwise_comp[[i]]$mean_pcor_diff_bggm_lkj <- summary_bggm[[i]]$pcor_mean - summary_lkj[[i]]$pcor_mean
    pairwise_comp[[i]]$mean_pcor_diff_lkj_iw <- summary_iw[[i]]$pcor_mean - summary_lkj[[i]]$pcor_mean
    
  }
  
  
  
  #--- Summarize results in performance measures
  # Comparisons against DGP
  mat_bias <- function(x){sum(abs(x))} # sum of absolute values of differences
  mat_mse <- function(x){sum(x^2)} # sum of squared differences
  
  bias_beta_bggm <- mean(sapply(comp_bggm, function(x){mat_bias(x$beta_diff)}))
  bias_beta_iw <- mean(sapply(comp_iw, function(x){mat_bias(x$beta_diff)}))
  bias_beta_lkj <- mean(sapply(comp_lkj, function(x){mat_bias(x$beta_diff)}))
  mse_beta_bggm <- mean(sapply(comp_bggm, function(x){mat_mse(x$beta_diff)}))
  mse_beta_iw <- mean(sapply(comp_iw, function(x){mat_mse(x$beta_diff)}))
  mse_beta_lkj <- mean(sapply(comp_lkj, function(x){mat_mse(x$beta_diff)}))
  
  
  bias_pcor_bggm <- mean(sapply(comp_bggm, function(x){mat_bias(x$rho_diff)}))
  bias_pcor_iw <- mean(sapply(comp_iw, function(x){mat_bias(x$rho_diff)}))
  bias_pcor_lkj <- mean(sapply(comp_lkj, function(x){mat_bias(x$rho_diff)}))
  mse_pcor_bggm <- mean(sapply(comp_bggm, function(x){mat_mse(x$rho_diff)}))
  mse_pcor_iw <- mean(sapply(comp_iw, function(x){mat_mse(x$rho_diff)}))
  mse_pcor_lkj <- mean(sapply(comp_lkj, function(x){mat_mse(x$rho_diff)}))
  
  
  # Comparisons between methods
  # Mean
  pairwise_mean_abs_diff <- lapply(pairwise_comp, function(x) {
  sapply(x, function(y) mean(abs(y), na.rm = TRUE))
  })
  
  # Convert to matrix for means
  pmad <- t(simplify2array(pairwise_mean_abs_diff))
  pmad_mean <- colMeans(pmad)
  
  
  #--- Return all results
  ret_summarise <- c(bias_beta_bggm = bias_beta_bggm,
                     bias_beta_iw = bias_beta_iw,
                     bias_beta_lkj = bias_beta_lkj,
                     mse_beta_bggm = mse_beta_bggm,
                     mse_beta_iw = mse_beta_iw,
                     mse_beta_lkj = mse_beta_lkj,
                     bias_pcor_bggm = bias_pcor_bggm,
                     bias_pcor_iw = bias_pcor_iw,
                     bias_pcor_lkj = bias_pcor_lkj,
                     mse_pcor_bggm = mse_pcor_bggm,
                     mse_pcor_iw = mse_pcor_iw,
                     mse_pcor_lkj = mse_pcor_lkj,
                     pmad = pmad_mean)
  
  return(ret_summarise)
}



```

# Execute Simulation

```{r}
sim_results <- SimDesign::runSimulation(design = df_design, 
                                    replications = 100, 
                                    generate = sim_generate, 
                                    analyse = sim_analyse, 
                                    summarise = sim_summarise, 
                                    fixed_objects = sim_pars,
                                    parallel = TRUE,
                                    packages = c("tidyverse", "BGGM", "graphicalVAR", "rstan", "here", "bayestestR"),
                                    save_results = TRUE,
                                    filename = "implementation-sim-results.rds",
                                    save_seeds = TRUE
                                    )

SimClean()
sim_sum <- SimExtract(sim_results, "summarise")

```

# Visualization

```{r}
sim_results 

```
