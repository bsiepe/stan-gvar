---
title: "bf-simulation-study"
format: html
editor: visual
---

# Preparation

```{r}
library(SimDesign)
library(tidyverse)
library(BGGM)
library(here)

source(here::here("scripts","functions.R"))
SimClean()

```

# Writing Simulation Functions

## Creating Design

```{r}
## Variable Objects
# Number of timepoints
tp <- c(75, 200, 1e3)

# Amount of change between DGP
change <- c("truegraph", "change1.6", "const0.5", "const1.5")

# Which dgp
dgp_num <- c("graph3", "graph4", "graph5")

# Number of variables
# cannot increase beyond 6 for the moment
nvar <- c(4, 6)

# scale for null range
null_scale <- c(.03, .04, .05)

df_design <- createDesign(
  tp = tp,
  change = change,
  null_scale = null_scale,
  nvar = nvar,
  dgp_num = dgp_num
  )

## Fixed Objects
# These are used in SimDesign to specify objects passed to later functions
# that do not vary across conditions

# DGPs
l_changed_graphs_0305 <- readRDS(here::here("data/l_changed_graphs_0305.rds"))


# gvar_mod_00 <- l_changed_graphs_0305[["graph5"]][["truegraph"]]
# gvar_mod_c16<- l_changed_graphs_0305[["graph5"]][["change1.6"]]
# gvar_mod_05 <- l_changed_graphs_0305[["graph5"]][["const0.1"]]
# gvar_mod_15 <- l_changed_graphs_0305[["graph5"]][["const0.15"]]
# dgp_list <- list("true" = gvar_mod_00,
#                  "change16" = gvar_mod_c16,
#                  "const05" = gvar_mod_05,
#                  "const15" = gvar_mod_15)

dgp_list <- l_changed_graphs_0305

# Further simulation parameters
sim_pars <- list(dgp_list = dgp_list,
                 means = 0,
                 rho_prior = 0.25,
                 beta_prior = 0.5,
                 bggm_iter = 1e4
                 )

```

## Data Generation Function

We always simulate from the "true" graph, and then simulate either from another "true" graph (i.e., same DGP), or from two alternative modificaitons.

```{r}
sim_generate <- function(condition, fixed_objects = NULL) {
  # obtain fixed parameters
  # this is NOT like the typical attach
  SimDesign::Attach(fixed_objects)
  
  # obtain condition parameters
  tp <- condition$tp
  change <- condition$change
  null_scale <- condition$null_scale
  dgp_list <- fixed_objects$dgp_list
  nvar <- condition$nvar
  dgp_num <- condition$dgp_num
  
  # Cut away variables depending on nvar
  # might ideally be better to create completely new network
  # because partial correlation dimension depend on number of variables
  # but we disregard that for now
  data_dgp_true <- dgp_list[[dgp_num]][["truegraph"]]
  data_dgp_change <- dgp_list[[dgp_num]][[change]]
  
  # TODO should add check that kappa leads to spd pcor
  
  
  # Simulate dataset under true
  data_true <-
    as.data.frame(
      graphicalVAR::graphicalVARsim(
        nTime = tp,
        beta = data_dgp_true$beta[1:nvar, 1:nvar],
        kappa = data_dgp_true$kappa[1:nvar, 1:nvar],
        mean = means
      )
    )
  
  # Standardize data
  data_true <- as.data.frame(scale(data_true))
  
  # Simulate dataset under change
  data_change <-
    as.data.frame(
      graphicalVAR::graphicalVARsim(
        nTime = tp,
        beta = data_dgp_change$beta[1:nvar, 1:nvar],
        kappa = data_dgp_change$kappa[1:nvar, 1:nvar],
        mean = means
      )
    )
  
  # Standardize data
  data_change <- as.data.frame(scale(data_change))
  
  l_data <- list(data_true = data_true,
                 data_change = data_change)
  
  return(l_data)
  
  
}

```

## Analysis Function

For now, only fit with BGGM, and then compute Bayes Factor.

```{r}
sim_analyse <- function(condition, dat, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)    
  
  #--- Fit BGGM model
  # On true data
  fit_bggm_true <- BGGM::var_estimate(dat$data_true,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  
  # On change data
  fit_bggm_change <- BGGM::var_estimate(dat$data_change,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  
  #--- Obtain Bayes Factor
  source(here::here("scripts","functions.R"))

  # BFs for Beta
  mat_comp_beta <- compare_matrices(
    mat1 = draws_array2matrix(fit_bggm_true$fit$beta),
    mat2 = draws_array2matrix(fit_bggm_change$fit$beta),
    parameter_type = "Beta", 
    bootstrap_samples = 0,
    H1_prior_scale = .5,
    H0_distribution = "uniform",
    H0_prior_scale = condition$null_scale,
    plot = FALSE
)
    # BFs for Beta for Rho
  mat_comp_rho <- compare_matrices(
    mat1 = draws_array2matrix(fit_bggm_true$fit$pcors),
    mat2 = draws_array2matrix(fit_bggm_change$fit$pcors),
    parameter_type = "Rho", 
    bootstrap_samples = 0,
    H1_prior_scale = .5,
    H0_distribution = "uniform",
    H0_prior_scale = condition$null_scale,
    plot = FALSE
)
  #--- Return
  ret_analyse <- data.frame(
    # Beta
    bf_beta = (mat_comp_beta[[1]]),
    log_bf_beta = (mat_comp_beta[[2]]),
    post_in_null_beta = mat_comp_beta[[3]],
    # Rho
    bf_rho = (mat_comp_rho[[1]]),
    log_bf_rho = (mat_comp_rho[[2]]),
    post_in_null_rho = mat_comp_rho[[3]]
    )
  
  return(ret_analyse)
  
}
```

## Summarize Function

```{r}
sim_summarise <- function(condition, results, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)  
 
  # Compute mean of Bayes Factor
  bf_median_beta <- median(results$bf_beta, na.rm = TRUE)
  bf_mad_beta <- mad(results$bf_beta, na.rm = TRUE)
  bf_median_rho <- median(results$bf_rho, na.rm = TRUE)
  bf_mad_rho <- mad(results$bf_rho, na.rm = TRUE)

  # Return all results
  ret_summarise <- data.frame(bf_median_beta = bf_median_beta,
                     bf_mad_beta = bf_mad_beta,
                     bf_median_rho = bf_median_rho,
                     bf_mad_rho = bf_mad_rho
                    )
  
  return(NULL)
}
```

# Run Simulation

```{r eval=FALSE}
cores <- parallel::detectCores() - 2

res <- runSimulation(design = df_design, 
                     packages = c("tidyverse", "here", "Rmpfr"),
                     replications = 1e3, 
                     ncores = cores,
                     generate = sim_generate, 
                     analyse = sim_analyse, 
                     summarise = sim_summarise, 
                     fixed_objects = sim_pars,
                     store_results = TRUE,
                     save_seeds = FALSE,
                     debug = 'all',
                     parallel = TRUE)

res <- SimExtract(res, what = 'results')
# save results
saveRDS(res, here::here("output", "bf_sim_res.rds"))
```

```{r}
res <- readRDS(here::here("output", "bf_sim_res.rds"))
```

# Analyze Simulation

```{r}
res <- res %>% mutate(
  is_null = ifelse(change == "true", 1, 0),
  true_diff_beta = ifelse(change == "true", 0, 1),
  detect_diff_beta = ifelse(log_bf_beta > 0 , 0, 1),
  correct_beta = ifelse(true_diff_beta == detect_diff_beta, 1, 0),
  abs_error_beta = abs(is_null - post_in_null_beta / 100),
  true_diff_rho = ifelse(change == "true", 0, 1),
  detect_diff_rho = ifelse(log_bf_rho > 0 , 0, 1),
  correct_rho = ifelse(true_diff_rho == detect_diff_rho, 1, 0),
  abs_error_rho = abs(is_null - post_in_null_rho / 100)
) %>%
  # per null_scale
  group_by(null_scale, tp) %>%
  mutate(
    sens_beta = mean(sum(true_diff_beta * detect_diff_beta) /
                       sum(true_diff_beta)),
    spec_beta = mean(sum(is_null * (
      detect_diff_beta * -1 + 1
    )) /
      sum(is_null)),
    sens_rho = mean(sum(true_diff_rho * detect_diff_rho) /
                      sum(true_diff_rho)),
    spec_rho = mean(sum(is_null * (
      detect_diff_rho * -1 + 1
    )) /
      sum(is_null))
  ) %>%
  ungroup()
  
sens_spec <- 
res %>% 
  distinct(tp,null_scale, sens_beta, spec_beta, sens_rho, spec_rho) %>% 
  arrange(tp) %>% 
  round(2)
sens_spec
```

```{r}
library(ggdist)
res %>%
  ggplot2::ggplot(aes(x = factor(tp), 
                      y = abs_error_beta,
                      fill = factor(tp), 
                      col = factor(tp))) +
  geom_boxplot(
    width = 0.3,
    alpha = 0.3
  ) +
  labs(title = "Beta",
       x = "timepoints",
       y = "absolute error") +
  scale_y_continuous(limits = c(0,1)) +
  facet_grid(change ~ null_scale)

```

```{r}
res %>%
  ggplot2::ggplot(aes(
    x = factor(tp),
    y = abs_error_rho,
    fill = factor(tp),
    col = factor(tp)
  )) +
  geom_boxplot(width = 0.3,
               alpha = 0.3) +
  labs(title = "Rho",
       x = "timepoints",
       y = "absolute error") +
  scale_y_continuous(limits = c(0,1)) +
  facet_grid(change ~ null_scale)
```

```{r}
res %>%
  ggplot2::ggplot(aes(x = factor(tp), 
                      y = log_bf_beta,
                      fill = factor(tp), 
                      col = factor(tp))) +
  geom_hline(yintercept = log(.01)) + 
  geom_hline(yintercept = log(100)) + 
  geom_boxplot(
    width = 0.3,
    alpha = 0.3
  ) +
  labs(title = "Beta",
       x = "timepoints",
       y = "bayes factor") +
  scale_y_continuous() +
  facet_grid(change ~ null_scale, scales = "free_y")
```

```{r}
res %>%
  ggplot2::ggplot(aes(x = factor(tp), 
                      y = log_bf_rho,
                      fill = factor(tp), 
                      col = factor(tp))) +
  geom_hline(yintercept = log(.01)) + 
  geom_hline(yintercept = log(100)) + 
  geom_boxplot(
    width = 0.3,
    alpha = 0.3
  ) +
  labs(title = "Rho",
       x = "timepoints",
       y = "bayes factor") +
  scale_y_continuous() +
  facet_grid(change ~ null_scale, scales = "free_y")
```
