---
title: "bf-simulation-study"
format: html
editor: visual
---

# Preparation

```{r}
library(SimDesign)
library(tidyverse)
library(BGGM)
library(here)

source(here::here("scripts","functions.R"))
SimClean()

```

# Writing Simulation Functions

## Creating Design

```{r}
## Variable Objects
# Number of timepoints
tp <- c(200, 400, 800)

# Amount of change between DGP
change <- c("true", "const05", "const15")

# scale for null range
null_scale <- c(.025, .05, .1)

df_design <- createDesign(
  tp = tp,
  change = change,
  null_scale = null_scale
  )

## Fixed Objects
# These are used in SimDesign to specify objects passed to later functions
# that do not vary across conditions

# DGPs
l_changed_graphs_0305 <- readRDS(here::here("data/l_changed_graphs_0305.rds"))

gvar_mod_00 <- l_changed_graphs_0305[["graph5"]][["truegraph"]]
gvar_mod_05 <- l_changed_graphs_0305[["graph5"]][["const0.1"]]
gvar_mod_15 <- l_changed_graphs_0305[["graph5"]][["const0.15"]]
dgp_list <- list("true" = gvar_mod_00,
                 "const05" = gvar_mod_05,
                 "const15" = gvar_mod_15)

# Further simulation parameters
sim_pars <- list(dgp_list = dgp_list,
                 means = 0,
                 nvar = 6,
                 rho_prior = 0.25,
                 beta_prior = 0.5,
                 bggm_iter = 1e4
                 )

```

## Data Generation Function

We always simulate from the "true" graph, and then simulate either from another "true" graph (i.e., same DGP), or from two alternative modificaitons.

```{r}
sim_generate <- function(condition, fixed_objects = NULL) {
  # obtain fixed parameters
  # this is NOT like the typical attach
  SimDesign::Attach(fixed_objects)
  
  # obtain condition parameters
  tp <- condition$tp
  change <- condition$change
  null_scale <- condition$null_scale
  dgp_list = fixed_objects$dgp_list
  
  # Simulate dataset under true
  data_true <-
    as.data.frame(
      graphicalVAR::graphicalVARsim(
        nTime = tp,
        beta = dgp_list[["true"]]$beta,
        kappa = dgp_list[["true"]]$kappa,
        mean = means
      )
    )
  
  # Standardize data
  data_true <- as.data.frame(scale(data_true))
  
  # Simulate dataset under change
  data_change <-
    as.data.frame(
      graphicalVAR::graphicalVARsim(
        nTime = tp,
        beta = dgp_list[[change]]$beta,
        kappa = dgp_list[[change]]$kappa,
        mean = means
      )
    )
  
  # Standardize data
  data_change <- as.data.frame(scale(data_change))
  
  l_data <- list(data_true = data_true,
                 data_change = data_change)
  
  return(l_data)
  
  
}

```

## Analysis Function

For now, only fit with BGGM, and then compute Bayes Factor.

```{r}
sim_analyse <- function(condition, dat, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)    
  
  #--- Fit BGGM model
  # On true data
  fit_bggm_true <- BGGM::var_estimate(dat$data_true,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  
  # On change data
  fit_bggm_change <- BGGM::var_estimate(dat$data_change,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  
  #--- Obtain Bayes Factor
  source(here::here("scripts","functions.R"))

  # BFs for Beta
  mat_comp_beta <- compare_matrices(
    mat1 = draws_array2matrix(fit_bggm_true$fit$beta),
    mat2 = draws_array2matrix(fit_bggm_change$fit$beta),
    parameter_type = "Beta", 
    bootstrap_samples = 0,
    H1_prior_scale = .5,
    H0_distribution = "uniform",
    H0_prior_scale = condition$null_scale,
    plot = FALSE
)
    # BFs for Beta for Rho
  mat_comp_rho <- compare_matrices(
    mat1 = draws_array2matrix(fit_bggm_true$fit$pcors),
    mat2 = draws_array2matrix(fit_bggm_change$fit$pcors),
    parameter_type = "Rho", 
    bootstrap_samples = 0,
    H1_prior_scale = .5,
    H0_distribution = "uniform",
    H0_prior_scale = condition$null_scale,
    plot = FALSE
)
  #--- Return
  ret_analyse <- data.frame(
    # Beta
    bf_beta = (mat_comp_beta[[1]]),
    log_bf_beta = (mat_comp_beta[[2]]),
    post_in_null_beta = mat_comp_beta[[3]],
    # Rho
    bf_rho = (mat_comp_rho[[1]]),
    log_bf_rho = (mat_comp_rho[[2]]),
    post_in_null_rho = mat_comp_rho[[3]]
    )
  
  return(ret_analyse)
  
}
```

## Summarize Function

```{r}
sim_summarise <- function(condition, results, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)  
 
  # Compute mean of Bayes Factor
  bf_median_beta <- median(results$bf_beta, na.rm = TRUE)
  bf_mad_beta <- mad(results$bf_beta, na.rm = TRUE)
  bf_median_rho <- median(results$bf_rho, na.rm = TRUE)
  bf_mad_rho <- mad(results$bf_rho, na.rm = TRUE)

  # Return all results
  ret_summarise <- data.frame(bf_median_beta = bf_median_beta,
                     bf_mad_beta = bf_mad_beta,
                     bf_median_rho = bf_median_rho,
                     bf_mad_rho = bf_mad_rho
                    )
  
  return(NULL)
}
```

# Run Simulation

```{r eval=FALSE}
cores <- parallel::detectCores()-4
res <- runSimulation(design = df_design, 
                     packages = c("tidyverse", "here", "Rmpfr"),
                     replications = cores * 5, 
                     ncores = cores,
                     generate = sim_generate, 
                     analyse = sim_analyse, 
                     summarise = sim_summarise, 
                     fixed_objects = sim_pars,
                     store_results = TRUE,
                     save_seeds = FALSE,
                     parallel = TRUE)

res <- SimExtract(res, what = 'results')
# save df with results

saveRDS(res, here::here("output", "bf_sim_res"))

```

```{r}
res <- readRDS(here::here("output", "bf_sim_res"))
```

```{r}
res <- res %>% mutate(
  true_diff = ifelse(change == "true", 0, 1),
  is_null = ifelse(change == "true", 1, 0),
                      detect_diff = ifelse(log_bf_beta > 0 , 0, 1),
                      correct = ifelse(true_diff == detect_diff, 1, 0),
                      correct2 = is_null - post_in_null_beta/100) %>% 
  group_by(null_scale, change) %>% 
  mutate(perc_correct = mean(correct, na.rm = TRUE),
         perc_correct2 = mean(correct2, na.rm = TRUE))

res %>% distinct(null_scale,change, perc_correct2)
```

```{r}
library(ggdist)
res %>%
  ggplot2::ggplot(aes(x = factor(tp), 
                      y = -1*log_bf_beta,
                      fill = factor(tp))) +
  
  geom_hline(yintercept = log(100)) +

  # add half-violin from {ggdist} package
  # stat_halfeye(
  #   # adjust bandwidth
  #   #adjust = 0.5,
  #   # move to the right
  #   #justification = -0.2,
  #   # remove the slub interval
  #   #.width = 0,
  #   #point_colour = NA
  # ) +
  geom_boxplot(
    width = 0.2,
    # removing outliers
    #outlier.color = NA,
    alpha = 0.5
  ) +
  scale_y_continuous(limits = c(-50, 500)) +
  facet_grid(change ~ null_scale, space = "free_y")

```

```{r}
res %>%
  ggplot2::ggplot(aes(x = factor(tp), 
                      y = bf_rho,
                      fill = factor(tp))) +

  # add half-violin from {ggdist} package
  stat_halfeye(
    # adjust bandwidth
    #adjust = 0.5,
    # move to the right
    justification = -0.2,
    # remove the slub interval
    .width = 0,
    point_colour = NA
  ) +
  geom_boxplot(
    width = 0.2,
    # removing outliers
    #outlier.color = NA,
    alpha = 0.5
  ) +
  # stat_dots(
  #   # ploting on left side
  #   side = "left",
  #   # adjusting position
  #   justification = 1.1,
  #   # adjust grouping (binning) of observations
  #   binwidth = 0.25
  # ) +
  facet_grid(change ~ null_scale, space = "free_y")
```

# Analyze Simulation

```{r}
sim_sum <- SimExtract(res, "summarise")
sim_sum
```
