---
title: "bf-simulation-study"
format: html
editor: visual
---

# Preparation

```{r}
library(SimDesign)
library(tidyverse)
library(BGGM)
library(here)

source(here::here("scripts","functions.R"))

```

# Writing Simulation Functions

## Creating Design

```{r}
## Variable Objects
# Number of timepoints
tp <- 400

# Amount of change between DGP
change <- c("true", "const05", "const15")

# scale for null range
null_scale <- c(.005, .01, .05, .1)

df_design <- createDesign(
  tp = tp,
  change = change,
  null_scale = null_scale
  )

## Fixed Objects
# These are used in SimDesign to specify objects passed to later functions
# that do not vary across conditions

# DGPs
l_changed_graphs_0305 <- readRDS(here::here("data/l_changed_graphs_0305.rds"))

gvar_mod_00 <- l_changed_graphs_0305[["graph5"]][["truegraph"]]
gvar_mod_05 <- l_changed_graphs_0305[["graph5"]][["const0.1"]]
gvar_mod_15 <- l_changed_graphs_0305[["graph5"]][["const0.15"]]
dgp_list <- list("true" = gvar_mod_00,
                 "const05" = gvar_mod_05,
                 "const15" = gvar_mod_15)

# Further simulation parameters
sim_pars <- list(dgp_list = dgp_list,
                 means = 0,
                 nvar = 6,
                 rho_prior = 0.25,
                 beta_prior = 0.5,
                 bggm_iter = 1e4
                 )

```

## Data Generation Function

We always simulate from the "true" graph, and then simulate either from another "true" graph (i.e., same DGP), or from two alternative modificaitons.

```{r}
sim_generate <- function(condition, fixed_objects = NULL) {
  # obtain fixed parameters
  # this is NOT like the typical attach
  SimDesign::Attach(fixed_objects)
  
  # obtain condition parameters
  tp <- condition$tp
  change <- condition$change
  null_scale <- condition$null_scale
  dgp_list = fixed_objects$dgp_list
  
  # Simulate dataset under true
  data_true <-
    as.data.frame(
      graphicalVAR::graphicalVARsim(
        nTime = tp,
        beta = dgp_list[["true"]]$beta,
        kappa = dgp_list[["true"]]$kappa,
        mean = means
      )
    )
  
  # Standardize data
  data_true <- as.data.frame(scale(data_true))
  
  # Simulate dataset under change
  data_change <-
    as.data.frame(
      graphicalVAR::graphicalVARsim(
        nTime = tp,
        beta = dgp_list[[change]]$beta,
        kappa = dgp_list[[change]]$kappa,
        mean = means
      )
    )
  
  # Standardize data
  data_change <- as.data.frame(scale(data_change))
  
  l_data <- list(data_true = data_true,
                 data_change = data_change)
  
  return(l_data)
  
  
}

```

## Analysis Function

For now, only fit with BGGM, and then compute Bayes Factor.

```{r}
sim_analyse <- function(condition, dat, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)    
  
  #--- Fit BGGM model
  # On true data
  fit_bggm_true <- BGGM::var_estimate(dat$data_true,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  
  # On change data
  fit_bggm_change <- BGGM::var_estimate(dat$data_change,
                                 rho_sd = rho_prior,
                                 beta_sd = beta_prior,
                                 iter = bggm_iter, 
                                 progress = FALSE)
  
  #--- Obtain Bayes Factor
  source(here::here("scripts","functions.R"))

  # BFs for Beta
  mat_comp_beta <- compare_matrices(
    mat1 = draws_array2matrix(fit_bggm_true$fit$beta),
    mat2 = draws_array2matrix(fit_bggm_change$fit$beta),
    parameter_type = "Beta", 
    bootstrap_samples = 0,
    H1_prior_scale = .5,
    H0_distribution = "uniform",
    H0_prior_scale = condition$null_scale,
    plot = FALSE
)
    # BFs for Beta for Rho
  mat_comp_rho <- compare_matrices(
    mat1 = draws_array2matrix(fit_bggm_true$fit$pcors),
    mat2 = draws_array2matrix(fit_bggm_change$fit$pcors),
    parameter_type = "Rho", 
    bootstrap_samples = 0,
    H1_prior_scale = .5,
    H0_distribution = "uniform",
    H0_prior_scale = condition$null_scale,
    plot = FALSE
)
  #--- Return
  ret_analyse <- c(
    # Beta
    bf_beta = mat_comp_beta[[1]],
    log_bf_beta = mat_comp_beta[[2]],
    post_in_null_beta = mat_comp_beta[[3]],
    # Rho
    bf_rho = mat_comp_rho[[1]],
    log_bf_rho = mat_comp_rho[[2]],
    post_in_null_rho = mat_comp_rho[[3]]
    )
  
  return(ret_analyse)
  
}
```

## Summarize Function

```{r}
sim_summarise <- function(condition, results, fixed_objects = NULL) {
  
  SimDesign::Attach(fixed_objects)  

  # Compute mean of Bayes Factor
  bf_mean_beta <- mean(results$bf_beta)
  bf_sd_beta <- sd(results$bf_beta)
  bf_mean_rho <- mean(results$bf_rho)
  bf_sd_rho <- sd(results$bf_rho)
  
  # Return all results
  ret_summarise <- c(bf_mean_beta = bf_mean_beta,
                     bf_sd_beta = bf_sd_beta,
                     bf_mean_rho = bf_mean_rho,
                     bf_sd_rho = bf_sd_rho
                    )
  
  return(ret_summarise)
}
```

# Run Simulation

```{r}
res <- runSimulation(design = df_design, 
                     packages = c("tidyverse", "here"),
                     replications = 100, 
                     generate = sim_generate, 
                     analyse = sim_analyse, 
                     summarise = sim_summarise, 
                     fixed_objects = sim_pars,
                     store_results = TRUE,
                     save_seeds = FALSE,
                     parallel = TRUE)

res_df <- SimExtract(res, what = 'results')

```

```{r}
res_df
```

```{r}
res_df%>%
  ggplot2::ggplot() +
  geom_boxplot(aes(y = mean(log_bf_beta))) +
  facet_grid(change ~ null_scale)

```

# Analyze Simulation

```{r}
sim_sum <- SimExtract(res, "summarise")
sim_sum
```
